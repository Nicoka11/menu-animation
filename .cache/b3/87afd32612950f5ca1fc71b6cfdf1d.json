{"id":"node_modules/l/src/Line.js","dependencies":[{"name":"G:\\Z - Web Training\\menu-animation\\package.json","includedInParent":true,"mtime":1619633306767},{"name":"G:\\Z - Web Training\\menu-animation\\node_modules\\l\\package.json","includedInParent":true,"mtime":1619633300165},{"name":"stream","loc":{"line":2,"column":23},"parent":"G:\\Z - Web Training\\menu-animation\\node_modules\\l\\src\\Line.js","resolved":"C:\\Users\\nicok\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\stream-browserify\\index.js"},{"name":"./utilities","loc":{"line":4,"column":26},"parent":"G:\\Z - Web Training\\menu-animation\\node_modules\\l\\src\\Line.js","resolved":"G:\\Z - Web Training\\menu-animation\\node_modules\\l\\src\\utilities.js"},{"name":"./debug","loc":{"line":162,"column":63},"parent":"G:\\Z - Web Training\\menu-animation\\node_modules\\l\\src\\Line.js","resolved":"G:\\Z - Web Training\\menu-animation\\node_modules\\l\\src\\debug.js"},{"name":"process","parent":"G:\\Z - Web Training\\menu-animation\\node_modules\\l\\src\\Line.js","resolved":"C:\\Users\\nicok\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\process\\browser.js"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\nconst stream = require('stream');\n\nconst utilities = require('./utilities');\n\nclass Line {\n  constructor(segments) {\n    this.segments = segments.map(utilities.expandSegment);\n  }\n\n  execute() {\n    var args = Array.from(arguments);\n    var ctxt, cb;\n\n    if (args.length > 0 && typeof args[args.length - 1] === 'function') {\n      cb = args.pop();\n    }\n\n    if (args.length > 1 && typeof args[args.length - 1] === 'object') {\n      ctxt = args.pop();\n    } else {\n      ctxt = {};\n    }\n\n    debug('>executing on:', args, `(${this.segments.length} segments)`);\n    var p;\n\n    if (!cb) {\n      var rs, rj;\n\n      cb = function (err, result) {\n        if (err) {\n          rj(err);\n        } else {\n          rs(result);\n        }\n      };\n\n      p = new Promise(function (resolve, reject) {\n        rs = resolve;\n        rj = reject;\n      });\n    }\n\n    this.next(0, args, ctxt || {}, cb);\n    return p;\n  }\n\n  next(step, args, ctxt, cb) {\n    var self = this;\n    var segment = this.segments[step];\n    var value = args[0];\n    var isReadableStream = value instanceof stream.Readable;\n\n    if (segment && segment.$type === 'stream') {\n      var s = segment.$func.call(ctxt);\n\n      if (isReadableStream) {\n        debug('  ', step, '|piping to stream...');\n        value.pipe(s);\n      } else {\n        debug('  ', step, '!writing to stream...');\n        s.write(value);\n        s.end();\n      }\n\n      self.next(step + 1, [s], ctxt, cb);\n    } else if (isReadableStream) {\n      debug('  ', step, '@consuming readable stream...');\n      utilities.bufferStream(value).then(buf => self.next(step, [buf], ctxt, cb)) // FIXME write a test and correctly handle this (streams may err but continue to work?)\n      .catch(cb);\n    } else if (segment) {\n      var meta = {};\n      Line.resolveSegment(segment, args, ctxt, meta).then(function (value) {\n        debug('  ', step, `<${meta.inferredType}`, value);\n        self.next(step + 1, value, ctxt, cb);\n      }).catch(function (error) {\n        if (!(error instanceof Error)) {\n          error = Object.assign(new Error(error), {\n            error\n          });\n        }\n\n        Object.assign(error, {\n          step,\n          value,\n          ctxt\n        });\n        return cb(error);\n      });\n    } else {\n      debug('<finished with', args);\n      cb.apply(null, [null].concat(args));\n    }\n  }\n\n  static resolveSegment(segment, args, ctxt, meta) {\n    // This should be rewritten in a better way?\n    var ret;\n    var asyncCallback, rs, rj; // Should let streams pipe everywhere, even through segments\n\n    if (segment.$type === 'split') {\n      var promises = [];\n      var promisesKeys = [];\n\n      for (var key in segment) {\n        if (key[0] === '$') continue;\n        promisesKeys.push(key);\n\n        if (segment[key].$type === 'stream') {\n          let stream = segment[key].$func.call(ctxt);\n          stream.end(args[0]);\n          promises.push(utilities.bufferStream(stream));\n        } else if (segment[key].$type === 'promise') {\n          promises.push(segment[key].$func);\n        } else {\n          promises.push(Line.resolveSegment(segment[key], args, ctxt, {}).then(r => r[0]).then(utilities.bufferIfStream));\n        }\n      }\n\n      return Promise.all(promises).then(function (results) {\n        var all = {};\n\n        for (var i = 0; i < promisesKeys.length; ++i) {\n          debug('      <', promisesKeys[i], results[i]);\n          all[promisesKeys[i]] = results[i];\n        }\n\n        meta.inferredType = 'split';\n        return [all];\n      });\n    }\n\n    if (segment.$type === 'async' || segment.$type === 'auto') {\n      asyncCallback = function (error, value) {\n        var args = Array.from(arguments);\n        process.nextTick(function () {\n          // Give a chance for rs and rj to be set in case it is directly called\n          // Test: main/calling done immediately inside segment\n          if (error) {\n            return rj(error);\n          }\n\n          rs(args.slice(1));\n        });\n      };\n    }\n\n    try {\n      ret = segment.$func.apply(ctxt, args.concat(asyncCallback));\n    } catch (error) {\n      meta.inferredType = 'sync';\n      return Promise.reject(error);\n    }\n\n    if (typeof ret === 'undefined' && segment.$type === 'auto' || segment.$type === 'async') {\n      // I guess there is a better way to do this along with the above asyncCallback...\n      meta.inferredType = 'async';\n      return new Promise(function (resolve, reject) {\n        rs = resolve;\n        rj = reject;\n      });\n    } else if (ret instanceof Promise || ret && typeof ret.then === 'function' && typeof ret.catch === 'function') {\n      meta.inferredType = 'promise';\n      return ret.then(res => [res]);\n    } else {\n      meta.inferredType = 'sync';\n      return Promise.resolve([ret]);\n    }\n  }\n\n}\n\nmodule.exports = Line;\nvar debug = /^line(:|$)/.test(undefined) ? require('./debug') : () => {};"},"sourceMaps":null,"error":null,"hash":"ab9a2e0f7f51c894cdacd77255724427","cacheData":{"env":{}}}